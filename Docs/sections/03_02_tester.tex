\subsection{Проектирование и разработка программного средства создания пакетов вопросов}
\label{sec:design:tester}

Перед тем как проводить викторины, сначала необходимо создать пакет с вопросами, для этой задачи и существует программное средство создания пакетов вопросов. Предполагается, что им
может пользоваться кто угодно, а созданную викторину можно распространить по сети Интернет, чтобы другие игроки также смогли попробовать ее провести.

Сама по себе викторина делится на раунды, раунды в свою очередь делятся на темы, а каждая тема содержит перечень вопросов, на которые нужно отвечать. Проектируемое программное
средство должно уметь создавать пакеты с вопросами с помощью графического пользовательского интерфейса, а также иметь возможность редактировать уже существующие пакеты. Рассмотрим
решение каждой из задач подробнее и выясним наиболее предпочтительные подходы к разработке.

\subsubsection{} Проектирование типа данных викторины
\label{sec:design:tester:data}

Проектирование будет проводится снизу вверх, поэтому типы данных идут от самого низкоуровнего к самому высокоуровневому.

Программное средство должно поддерживать простой тип вопросов, суть которого заключается в том, что игрок, 
первый пожелавший дать ответ на него и отвечает, в случае правильного ответа очки начисляются на счет, в случае неправильного -- отнимаются.
В данной версии программного средства закладываются архитектурные основы для дальнейшего расширения по необходимости.

Для реализации этого типа данных можно использовать перечислимый тип (enumerable), поддержка которого есть в \csharp. Его главным достоинством является то, что программист может 
дать осмысленные имена числовым константам и избавится от "магических" чисел в коде \cite{book_makkonel}, что облегчает дальнейшее понимание и разработку программного обеспечения. Но в данном программном средстве
лучше воспользоваться объектно-ориентированным подходом и использовать интерфейс с конкретными реализациями. Как это сделать будет описано позже.

Помимо типов вопросов, сам вид содержимого вопросов может также отличаться. Должны поддерживаться следующие виды вопросов:

\begin{itemize}
	\item текст, представляющий из себя одно или несколько предложений;
	\item изображение, которое отображается в течении нескольких секунд;
	\item звук, играющий от начала и до конца;
	\item видеоролик, играющий от начала и до конца.
\end{itemize}

Для реализации данных видов вопросов стоит использовать массив байт, который представляет из себя абстрактное содержимое вопроса, таким образом
можно представить абсолютно любой тип содержимого, для которого в будущем будет необходимо реализовать обработчики. Также для высокоуровневой
отметки типа данных можно использовать перечислимый тип описанный выше, таким образом обработчики смогут корректно преобразовать массив байт в нужный тип контента.
Доступ к контенту в данной версии программного средства будет единственный и будет является встроенным, т. е. локальной копией, находящейся на компьютере.
Задаток для интернет-контента будет заложен в архитектуре.

Описав примитивы, являющиеся частью вопроса можно перейти к проектированию самого вопроса. Любой вопрос состоит из следующих полей:

\begin{itemize}
	\item тип вопроса;
	\item тип содержимого вопроса;
	\item тип доступа к содержимому вопроса;
	\item подсказка к ответу на вопрос;
	\item стоимость ответа на вопрос, которая будет прибавлятся или отниматься;
	\item содержимое вопроса, представленное массивом байт;
	\item сноска для организатора с правильным ответом на вопрос.
\end{itemize}

Для всех вопросов будет использоваться класс Question, содержащий в себе все поля необходимые для работы. 
В дальнейшем для различия типов вопросов в C\# предусмотрена концепция под названием pattern-matching \cite{msdn_pattern_matching}, позволяющая передавать управление в разные ветви программы, в зависимости
от типа данных, который скрывается за интерфейсом либо от значения некоего поля, такой подход позволяет использовать более удобный синтаксис, а также повышает расширяемость программы за счет того, что в будущем
различные типы могут существенно различаться, а управляющие конструкции уже менять не придется.

Категории вопросов отражают какую-то общую тему, по которой были составлены вопросы. Категория должна содержать следующие поля:

\begin{itemize}
	\item список вопросов;
	\item название категории.
\end{itemize}

Здесь стоит отметить, что сам список вопросов тоже должен является абстракцией, для этого в C\# предусмотрено несколько интерфейсов, например IList. Абстракция позволяет не
опираться на конкретные реализации, что в свою очередь уменьшает связанность, повышает сопровождаемость и уменьшает объем кода, который необходимо написать при расширении.

По аналогии с категориями проектируются и раунды, из которых собственно и состоит викторина. Раунд должен содержать следующие поля:

\begin{itemize}
	\item cписок категорий;
	\item название категории.
\end{itemize}

Здесь нужно обратить внимание на то, что абстракции не применяются для полей раунда, так как подразумевается что будет существовать только одна имплементация, поэтому 
необходимость в дополнительном уровне абстракций отпадает сама собой. Это соответствует одному из принципов програмированния под названием KISS -- keep it simple, stupid.

Сама викторина будет агрегировать в себе уже разработанные типы данных и состоять только лишь из списка раундов. Разработанный тип данных и будет результатом создания в 
программе по созданию пакетов вопросов и в дальнейшем использоваться для проведения викторин в приложении-клиенте.

\subsubsection{} Проектирование функции редактирования викторин
\label{sec:design:tester:editor}

Так как программное средство представляет из себя CRU (create, read, update) приложение, то для упрощения разработки стоит использовать технологию WPF от компании Microsoft.
Ключевой особенностью данной технологии является уникальный подход к работе с данными. Этот подход называется MVVM -- model, view, viewmodel и основывается на механизме привязки к данным \cite{book_mvvm}.
Рассмотрим сам механизм и отдельные уровни подробнее.

Уровень view представляет из себя набор представлений, которые пользователь видит в качестве пользовательского интерфейса приложения \cite{book_mvvm}. Он выглядит как набор кнопок, полей для ввода 
и прочих интерактивных элементов. На этом уровне задаются формат ввода данных, сами интерактивные элементы, валидации, а также стили. Каждое представление имеет свой формат файла 
с расширением .xaml. Этот файл состоит из двух подфайлов, разделяющих функции: файл разметки, содержащий описание того, как отображать элементы, а также файл логики, содержащий
минимальную логику по обработке информации с элементов интерфейса. Именно на этом уровне используется механизм привязки к данных (data binding) модели представления.

Модель представления (viewmodel) -- это промежуточный уровень между бизнес-логикой и самим представлением, его задача заключается в получении данных от слоя model и передачу оного в слой view \cite{book_mvvm}.
Для этого все модели представления реализуют интерфейс INotifyPropertyChanged, который содержит одно единственное поле-событие: PropertyChanged. Когда происходит связывание представления
и модели представления, то представление подписывается на событие PropertyChanged и автоматически перерисовывает элементы управления, которые были связаны с обновляемыми данными. В свою
очередь модель представления после обновления данных уведомляет представление о том, что данные действительно изменились, для этого происходит вызов Invoke в событии PropertyChanged. 

Привязка к данным -- подход, который позволяет четко разделить уровень представлений и моделей представлений, для настройки его правильной работы необходимо выполнить следующие
действия:

\begin{enumerate}
	\item создать модель представления, которая реализует интерфейс INoti-fyPropertyChanged;
	\item добавить требуемые свойства в класс, к которым будет осуществляться привязка;
	\item установить контекст данных (datacontext) представления на экземпляр класса модели представления;
	\item в файле с разметкой представления использовать binding синтаксис для привязки к свойствам модели представления.
\end{enumerate}

При таком подходе все изменения на пользовательском интерфейсе будут автоматически отражаться в хранимых типах данных и наоборот. Это избавляет программиста от большого количества
однообразного кода, который не выполняет ничего полезного, а только лишь создает/обновляет/удаляет простые данные.

Уровень модели представляет из себя весь набор бизнес-логики, которая необходима приложению для выполнения поставленных задач \cite{book_mvvm}. 
Сюда входит все, что не является простым манипулированием данными. Методы из этого уровня вызываются из модели представления, а аргументы для вызова в свою очередь беруться из представления.
Таким образом уровни приложения связаны достаточно свободно, что облегчает изменение и расширение, но в то же время обеспечивает достаточный уровень удобства при разработке.

\subsubsection{} Проектирование функций сохранения и открытия викторины
\label{sec:design:tester:open_save}

После того, как была спроектирована викторина, ее необходимо представить в однообразном виде, который будет понятен как программному средству для создания пакетов вопросов, так и
игровому клиенту. Для решения поставленной задачи можно прибегнуть к концепту сериализации \cite{msdn_serialization}. Суть сериализации заключается в следующем:
любой объект можно однозначно представить в некоем формате, например, для передачи по сети, а затем из этого формата получить объект обратно. Процесс перевода объекта в некий формат
называется сериализацией, а процесс перевода из формата в объект называется десериализацией.

В настоящее время популярны несколько форматов сериализации:

\begin{itemize}
	\item JSON -- JavaScript object notation;
	\item XML -- Extensible markup language;
	\item бинарное представление (массив байт).
\end{itemize}

Рассмотрим каждый из форматов подробнее:

JSON -- является одним из самым популярных форматов сериализации, применяется во многих областях разработки: настольные приложения, веб-приложения и даже базы данных. Простота,
читаемость и относительно небольшой размер сериализованных объектом обеспечили ему достаточно прочные позиции в списке популярных форматов сереализации.

XML -- является вторым по популярности после JSON, имея все преимущества первого он все же проигрывает в читаемости за счет дублирования тегов, а также сериализованные объекты
имеют больший размер за счет того, что сами теги могут попрой занимать больше места чем данные, которые в них хранятся.

Бинарный формат -- является самым простым и компактным из приведенных. Главным недостатком является абсолютная нечитаемость без посторонних инструментов, благодаря чему он особенно
не популярен в веб-разработке. Тем не менее, для разработки настольных приложений он более чем годится. Минимальный размер сериализации, возможность сериализовать циклические зависимости 
и простота использования являются серьезными преимуществами при разработке сетевых приложений, передача данных которых должны происходить как можно реже и как можно меньшими объемами.

Для сериализации пакетов с вопросами будет использоваться бинарный формат, так как сериализация музыки и видео обусловлена значительными трудностями при использовании иных форматов.
Кроме того, подразумевается, что пакет будет передаваться по сети другим игрокам, поэтому данный способ является наиболее предпочтительным среди аналогов.